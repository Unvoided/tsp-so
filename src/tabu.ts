import type { TspFile, Node } from "./loader.ts";
import { calculateTourDistance, twoOptSwap } from "./common.ts";
import { nearestNeighbour } from "./neighbour.ts";

/**
 * Performs the Tabu Search metaheuristic to solve the Traveling Salesman Problem (TSP).
 *
 * This function starts with an initial solution generated by the nearest neighbour heuristic,
 * then iteratively explores the neighborhood of the current solution using 2-opt swaps.
 * It maintains a tabu list to avoid cycling back to recently visited solutions, but allows
 * tabu moves if they result in a new best solution (aspiration criterion).
 *
 * @param tsp - The TSP problem instance containing the nodes to visit.
 * @param maxIterations - The maximum number of iterations to perform (default: 100).
 * @returns An object containing:
 *   - `bestSolution`: The best tour found as an array of nodes.
 *   - `bestDistance`: The total distance of the best tour found.
 *   - `initialDistance`: The distance of the initial solution.
 *   - `performance`: The elapsed time in milliseconds for the search process.
 */
export function tabuSearch(
  tsp: TspFile, // The TSP problem instance.
  maxIterations = 100 // Maximum number of iterations.
) {
  const performanceBegin = performance.now();

  // Generate an initial solution using the nearest neighbour heuristic.
  const initialSolution = nearestNeighbour(tsp.nodes);

  // Initialize current solution, best solution, and tabu list.
  let current = [...initialSolution];
  let bestSolution = [...current];
  let bestDistance = calculateTourDistance(current);
  const tabuList: { from: number; to: number }[] = [];

  // Main loop for a fixed number of iterations.
  for (let iter = 0; iter < maxIterations; iter++) {
    let bestNeighbor: Node[] = [];
    let bestNeighborCost = Infinity;
    let bestMove: { from: number; to: number } = { from: -1, to: -1 };

    // Explore all 2-opt neighbors of the current solution.
    for (let i = 1; i < current.length - 1; i++) {
      for (let k = i + 1; k < current.length; k++) {
        // Generate a neighbor by performing a 2-opt swap.
        const neighbor = twoOptSwap(current, i, k);
        const distance = calculateTourDistance(neighbor);

        // Check if the move is tabu, unless it improves the best solution (aspiration).
        const hasTabuMove = tabuList.some(
          (move) => move.from === i && move.to === k
        );
        if (
          (!hasTabuMove || distance < bestDistance) &&
          distance < bestNeighborCost
        ) {
          // Update the best neighbor found in this iteration.
          bestNeighbor = neighbor;
          bestNeighborCost = distance;
          bestMove = { from: i, to: k };
        }
      }
    }

    // If a valid neighbor is found, update current solution and tabu list.
    if (bestNeighbor.length > 0) {
      current = bestNeighbor;
      tabuList.push(bestMove);

      // If the neighbor improves the best solution, update the best solution.
      if (bestNeighborCost < bestDistance) {
        bestSolution = bestNeighbor;
        bestDistance = bestNeighborCost;
      }
    }
  }

  return {
    bestSolution,
    bestDistance,
    initialDistance: calculateTourDistance(initialSolution),
    performance: performance.now() - performanceBegin,
  };
}
